"""Goal planner that decomposes objectives into executable tasks."""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Iterable

from agent_core.model import ContextBudgetManager, LocalModel


@dataclass(slots=True)
class PlannedTask:
    """Executable task generated by the planner."""

    description: str
    adapter_hint: str
    priority: int = 100
    metadata: dict[str, str] = field(default_factory=dict)


class Planner:
    """Transforms high-level goals into task objects."""

    def __init__(self, model: LocalModel | None = None, budget_manager: ContextBudgetManager | None = None) -> None:
        self.model = model or LocalModel()
        self.budget_manager = budget_manager or ContextBudgetManager()

    def decompose(self, goal: str, context: Iterable[str] | None = None) -> list[PlannedTask]:
        context_lines = list(context or [])
        budgeted = self.budget_manager.apply_budget(context_lines, summarizer=self.model)
        prompt = self._build_prompt(goal, budgeted)
        response = self.model.generate(prompt, max_tokens=320)
        tasks = self._parse_tasks(response.text)
        return tasks or self._fallback_tasks(goal)

    def _build_prompt(self, goal: str, context: list[str]) -> str:
        joined_context = "\n".join(f"context: {line}" for line in context[-6:])
        return (
            "Goal decomposition request. Return concise task items.\n"
            f"goal: {goal}\n"
            f"{joined_context}".strip()
        )

    def _parse_tasks(self, text: str) -> list[PlannedTask]:
        tasks: list[PlannedTask] = []
        for idx, line in enumerate(text.splitlines()):
            stripped = line.strip().lstrip("- ").strip()
            if not stripped:
                continue
            adapter_hint = self._infer_adapter(stripped)
            tasks.append(
                PlannedTask(
                    description=stripped,
                    adapter_hint=adapter_hint,
                    priority=idx,
                    metadata={"source": "model"},
                )
            )
        return tasks

    def _fallback_tasks(self, goal: str) -> list[PlannedTask]:
        segments = [item.strip() for item in goal.replace(";", ".").split(".") if item.strip()]
        if not segments:
            segments = [goal.strip() or "Clarify objective"]
        return [
            PlannedTask(
                description=segment,
                adapter_hint=self._infer_adapter(segment),
                priority=idx,
                metadata={"source": "fallback"},
            )
            for idx, segment in enumerate(segments)
        ]

    def _infer_adapter(self, task_description: str) -> str:
        lowered = task_description.lower()
        if any(token in lowered for token in {"open", "navigate", "browser", "click", "page"}):
            return "browser"
        if any(token in lowered for token in {"tweet", "post", "social", "linkedin", "reddit", "instagram"}):
            return "social"
        return "terminal"
